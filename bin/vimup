#!/home/dotfiles/bin/env/bin/python
import argparse
import functools
import json
import os
import re
import shutil
import subprocess

import requests


def get_bundle(bundle, dirname):
    bundle, dirname = (s.strip('"\'') for s in (bundle, dirname))
    if '/' not in bundle:
        bundle = 'vim-scripts/%s' % bundle
    if not dirname:
        dirname = bundle.replace('/', '--')
    return bundle, dirname, 'https://github.com/%s' % bundle


def rc(filename, dirbase, no_install=False, clean=False):
    with open(filename, 'br') as f:
        text = f.read().decode()
    bundles_re = r'" ?Bundle ({0})(?: ({0}))?'.format('[^ \n]*')
    bundles = sorted(get_bundle(*i) for i in re.findall(bundles_re, text))
    print('Found %i bundles:' % len(bundles))

    if clean:
        dirs = [i[1] for i in bundles]
        for name in os.listdir(dirbase):
            path = os.path.join(dirbase, name)
            if name not in dirs and os.path.isdir(path):
                print('Remove %r' % path)
                shutil.rmtree(path)

    if not no_install:
        for i in bundles:
            install(i[0], i[1], dirbase=dirbase)
        return

    pretty_info = functools.partial(
        json.dumps, sort_keys=True, indent=4, separators=(',', ': ')
    )
    forbidden, info = False, {}
    for name, _, url in bundles:
        info[name] = url
        if not forbidden:
            res = requests.get('https://api.github.com/repos/' + name)
            if res.ok:
                info[name] = {
                    k: v for k, v in res.json().items()
                    if k in ('description', 'html_url', 'homepage', 'watchers')
                }
            else:
                forbidden = True
                print('Can\'t get info from github: %r %r' % (res, res.reason))

        print('%s: %s' % (name, pretty_info(info[name])))

    if not forbidden:
        with open(os.path.join(dirbase, 'bundles.txt'), 'bw') as f:
            f.write(pretty_info(info).encode())


def install(bundle, dirname, dirbase):
    dirbase = dirbase.rstrip('/')
    bundle, dirname, url = get_bundle(bundle, dirname)

    print('---\nProcess %r' % bundle)
    dirname = os.path.join(dirbase, dirname)
    if os.path.exists(dirname):
        subprocess.call('git pull origin master', cwd=dirname, shell=True)
    else:
        cmd = 'git clone --depth=1 %s.git %s' % (url, dirname)
        subprocess.call(cmd, shell=True)


def main(argv=None):
    parser = argparse.ArgumentParser('mail')
    cmds = parser.add_subparsers(help='commands')

    def cmd(name, **kw):
        p = cmds.add_parser(name, **kw)
        p.set_defaults(cmd=name)
        p.arg = lambda *a, **kw: p.add_argument(*a, **kw) and p
        p.exe = lambda f: p.set_defaults(exe=f) and p

        p.arg('-d', '--dirbase', default=os.path.expanduser('~/.vim/bundle'))
        return p

    cmd('install', aliases=['i'])\
        .arg('bundle')\
        .arg('dirname', nargs='?', default='')\
        .exe(lambda a: install(a.bundle, a.dirname, a.dirbase))

    cmd('rc', aliases=['r'])\
        .arg('-f', default=os.path.expanduser('~/.vimrc'))\
        .arg('-n', '--no-install', action='store_true')\
        .arg('-c', '--clean', action='store_true')\
        .exe(lambda a: rc(a.f, a.dirbase, a.no_install, a.clean))

    args = parser.parse_args(argv)
    if not hasattr(args, 'exe'):
        parser.print_usage()
    else:
        args.exe(args)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        raise SystemExit(1)
